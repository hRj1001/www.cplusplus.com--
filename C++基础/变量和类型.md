# 变量和类型

对于前面的“Hello World”程序，我们可能会有些疑问：我们写了好几行代码，编译它们，然后执行编译后的程序，就是为了在屏幕上输出几个字符？我们直接在屏幕上打出这些字符恐怕更快吧！

然而，编程不仅限于在屏幕上打出字符。为了能够快点写出能够完成有用的任务真正帮助我们工作的程序，我们需要了解一个概念叫*变量*。

想象一下，我让你记住一个数字5，然后我同时让你记住数字2，。你必须在你的记忆中存储这两个不同的数。现在，如果我让你给第一个数字加一，那么你的记忆中的两个数字就是6和2.然后我们可以让这些数字相减，那么就会得到结果4.

以上描述的整个进程就是一个关于计算机能用两个变量做什么的例子。相同的进程可以用以下的C++语句表达：

```
a = 5;
b = 2;
a = a + 1;
result = a - b;
```

很显然，这是一个很简单的例子，因为我们只使用了两个整型变量，但是你的电脑可以同时存储数百万像这样的数字，还能对它们进行复杂的数学运算。

现在，我们可以定义*变量*为一个能存储值的内存段。

每一个变量都需要一个名字标识它自己同时将它和其他变量区分开。比如说，前面的代码中，变量名字是*a，b，*和*result*，但是实际上我们可以给变量起我们能想到的任何名字，只要它们是合法的C++标识符。

## 标识符

一个合法的标识符是一个或多个字母、数字或下划线的序列。空格、标点符号和其他符号不能成为标识符的一部分。另外，标识符应当总是由字母开头。它们也可以用下划线开头，但是这种标识符大多数情况下被认为是编译器保留的特殊关键字或外部标识符，包含连续两个下划线开头的标识符也是一样。最后，标识符不可以由数字开头。

C++使用大量关键字来标识操作和数据描述，因此，程序员自己定义的标识符不可以包括这些关键字。不能被程序员使用的标准保留关键字有：

*alignas, alignof, and, and_eq, asm, auto, bitand, bitor, bool, break, case, catch, char, char16_t, char32_t, class, compl, const, constexpr, const_cast, continue, decltype, default, delete, do, double, dynamic_cast, else, enum, explicit, export, extern, false, float, for, friend, goto, if, inline, int, long, mutable, namespace, new, noexcept, not, not_eq, nullptr, operator, or, or_eq, private, protected, public, register, reinterpret_cast, return, short, signed, sizeof, static, static_assert, static_cast, struct, switch, template, this, thread_local, throw, true, try, typedef, typeid, typename, union, unsigned, using, virtual, void, volatile, wchar_t, while, xor, xor_eq*

特定的编译器也可能有额外的特定保留关键字。

**划重点：**C++是大小写敏感的语言。这意味着用大写字母的标识符和另一个用相同字母的小写字母的标识符是不相等的。因此，变量*RESULT*和*result*、*Result*都是不相等的。这是三个不同标识符标识的三个不同的变量。

## 基本数据类型

变量的值是在计算机内存的不确定的区域存储着的“0”和“1”。我们的程序不需要知道一个变量在内存中存储着的确切的位置。存储一个简单的整型数据和存储一个字母或者一个大的浮点数并不相同；即使它们都用0和1来表示，它们也不会用相同的方式区解释这些0和1，并且在许多情况下，它们占用的内存大小也不相同。

基本数据类型是由语言直接实现的基础类型，是大多数系统原生支持的基础存储单元。它们可以这样定义：

* 字符类型：它们可以表示一个单字符，比如‘A’或‘¥‘。大多数基础类型是*char*——一个字节的字符。也有其他类型的宽字符。

* 整型数字类型：它们可以存储一个整数，比如7或者1024.它们的大小是变化的，并且可以是有符号的也可以是无符号的，取决于它们是否支持负数。

* 浮点数类型：它们表示实数，比如3.14或者0.01，有不同的精度，取决于使用三种浮点类型中的哪一个。

* 布尔类型：在C++中是*bool*，只能是*true*或者*false*。

这是C++中基础类型的完整列表：

**Group** | **Type names**\* | **Notes on size / precision**
----- | ------------ | -----------------------
字符类型 | char | 只有一个字节至少8位.
字符类型  | char16_t | 不小于char，至少16位。
字符类型 | char32_t | 不小于char16_t. 至少32位.
字符类型 |wchar_t | 可以代表支持的最大字符集.
有符号整数	|signed char	|不小于char. 至少8位.
有符号整数|*signed* short *int*|不小于char. 至少16位.
有符号整数|*signed* int	|不小于short. 至少16位.
有符号整数|*signed* long *int*	|不小于int. 至少32位.
有符号整数|*signed* long long *int*|不小于long. 至少64位.
无符号整数|	unsigned char	|（和相应由符号数相同）
无符号整数|	unsigned short *int*	|（和相应由符号数相同）
无符号整数|	unsigned *int*	|（和相应由符号数相同）
无符号整数|	unsigned long *int*	|（和相应由符号数相同）
无符号整数|	unsigned long long *int* |（和相应由符号数相同）
浮点类型| float | 
浮点类型 | double | 精度不低于float
浮点类型| long double | 精度不低于double
布尔类型 | bool	
Void类型 | void | no storage
Null指针 | decltype(nullptr)

某些整型数据类型可以不带*signed*和*int*进行缩写，只有非斜体的部分是标识符必需的，斜体部分是可选的。比如，*signed short int*可以缩写成*signed short*，*short int*或者干脆写成*short*，它们都是同一种基础数据类型的标识符。

上面的每一组中，类型差异仅仅体现在它们的大小上（占用内存的多少）：每组的第一种类型是最小的，最后一种是最大的，每一种类型至少和它同组前一个的类型一样大。除此之外，每组中的类型具有相同的属性。

上面的表格中，只有char有固定的大小，其他基础数据类型都没有特定大小，但是它们有最小大小。因此，数据不严格要求是这个最小的大小。这不是说这些数据没有确定的大小，而是说在所有的编译器和机器上并没有一个统一的标准，每一个编译器实现中会确定这些类型的大小，来适应运行程序的机器的最好的架构。这些通用类型大小标准给了C++很大的灵活性，让C++可以在所有的平台上进行优化，现在是，未来也是。

数据类型是用位大小进行表示的，一个类型拥有的位数越多，它就能表示更多的值，但是同时，也会占用更多的内存空间。

**Size**| **Unique representable values** | **Notes**
--|--|--
8-bit	| 256	| = 28
16-bit	| 65 536	| = 216
32-bit	| 4 294 967 296	| = 232 (~4 billion)
64-bit	| 18 446 744 073 709 551 616	| = 264 (~18 billion billion)

对于整数来说，能表示更多的值意味着能表示的数的范围越大；比如说，16为的无符号数可以表示65535个不同的数，从0到65535，然而相应的有符号数可以表示-32768到32767.注意，与无符号数相比，有符号数的正数的值大约是无符号数的一半，因为16位中1位被用来当作符号位了，这是一个相对合适范围差异，并且很少纯粹基于它们能表示的正数大小来判断使用。

对于浮点数，它们的大小通过有效位或指数的多少来影响它们的精度。

如果不考虑大小或者精度，那么*char，int和double*是最常使用来表示字符，整数和浮点数值的。其他类型仅在非常特殊的情况下才会使用。

特定系统和编译器实现中基本类型的属性可以通过使用numeric_limits类获得（请参见标准头文件\<limits\>）。 如果由于某种原因需要特定大小的类型，则该库在头文件<cstdint>中定义某些固定大小的类型别名。

上面提到的类型统称为算术类型。但是还有两个额外的基础类型存在：*void*，标识无类型；和*nullptr*，是一种特殊的指针类型。这两种类型都会在后面有关指针的类型中讨论。

C++提供很多基于上面提到的基础类型的数据类型，它们被称为*复合数据类型*，并且是C++语言的一大利器。我们会在后面的章节中看到它们。

## 变量的声明

C++是一种强类型语言，并且要求每个变量在使用前必须声明它的类型。这可以告知编译器在内存中留出的大小以及如何解释这个值。在C++中声明一个新变量的语法很直接：我们就在变量的名字前面写上变量的类型。比如：

```
int a;
float mynumber;
```

上面是两个有效的变量声明。第一个声明了一个*int*类型的变量叫做*a*，第二个声明了一个*float*类型的变量叫做*mynumber*。一旦声明，变量*a*和*mynumber*就可以在下面的程序中使用了。
如果声明超过一个同类型变量，它们可以在同一个代码语句中通过逗号分隔标识符。比如：

`int a, b, c;`

以下是声明了三个变量的代码，类型都是int，并且和上面的代码意义相同：

```
int a;
int b;
int c;
```

为了看看在程序中变量定义看起来是什么样子，我们来看一段完整的C++代码例子，这个例子和本章开头的记数字的例子是一样的：

```
// operating with variables

#include <iostream>
using namespace std;

int main ()
{
  // declaring variables:
  int a, b;
  int result;

  // process:
  a = 5;
  b = 2;
  a = a + 1;
  result = a - b;

  // print out the result:
  cout << result;

  // terminate the program:
  return 0;
}
```

这段程序的输出是`4`.

如果变量声明的地方让你有些看不明白，没关系，我们会在下面的部分进行详细介绍。

## 变量的初始化

当上面例子中的变量被声明时，它们并没有一个确切的值，它们直到被第一次分配来一个值，才有了一个确切的值。但如果我们想要变量在声明时就有一个确切的值，也是可以的。这称为变量的*初始化*。

在C++中，有三种对变量进行初始化的方法。它们都是相等的，并且会让人回想起这些年语言的发展：

第一个，是*C语言风格*的初始化（因为这是从C语言中继承来的），由一个等号后面跟着变量被初始化为的值组成：

*type identifier = initial_value;*

举个例子，要在同一时刻声明一个叫做*x*的*int*类型变量并且初始化为0，我们可以这样写：

`int x = 0;`

第二种方法，称为*构造器初始化*（由C++语言引入），将要初始化的值用括号括起来放在变量名的后面：

*type identifier (initial_value);*

比如这样：

`int x(0);`

最后，第三种，称为*标准化初始化*，和上面的很像，但是使用的是花括号而不是圆括号（由C++2011引入）：

*type indentifier {initial_value};*

比如：

`int x {0};`

所有的三种方式在C++中都是有效并且相等的。

```
// initialization of variables

#include <iostream>
using namespace std;

int main ()
{
  int a=5;               // initial value: 5
  int b(3);              // initial value: 3
  int c{2};              // initial value: 2
  int result;            // initial value undetermined

  a = a + b;
  result = a - c;
  cout << result;

  return 0;
}
```

以上代码输出为`6`.

## 类型推断：auto和decltype

当一个新变量初始化的时候，编译器可以通过初始化的值判断出变量的类型。因此我们可以只使用*auto*作为变量的类型：

```
int foo = 0;
auto bar = foo;  // the same as: int bar = foo; 
```

在这里，*bar*被声明为*auto*类型，因此，*bar*的类型就是用于将它初始化的值的类型。在这个例子中，使用的是*foo*的类型，也就是*int*。

变量如果没有被初始化，我们也可以使用*decltype*来推断变量的类型：

```
int foo = 0;
decltype(foo) bar;  // the same as: int bar; 
```

在这个例子中，*bar*被声明为和*foo*具有相同的类型。

*auto*和*decltype*是C++语言中很有用的特性。但是变量推断注定被用在无法通过其它方式获得变量类型或者提升代码可读性的时候。上面的两个例子并不是刚刚提到的使用场景。事实上它们可能削弱代码的可读性，因为，当读代码的时候，不得不寻找*foo*的定义才知道*bar*的确切类型。

## 字符串介绍

基础数据类型表示代码运行时机器处理的大多数数据。但是C++的强大之一就是富含由基础数据类型组成的复合数据类型。

复合数据类型的例子之一，就是*string*类。这种类型的变量可以存储一连串的字符，比如句子或单词。真是个有用的特性！

和基础数据类型的第一个不同就是为了声明和使用这个类型的对象，程序必须包含定义这种数据类型的头文件(header\<string\>)：

```
// my first string
#include <iostream>
#include <string>
using namespace std;

int main ()
{
  string mystring;
  mystring = "This is a string";
  cout << mystring;
  return 0;
}
```

程序的输出为`This is a string`。

正如你在之前的例子中看到的那样，字符串可以由任意有效的字符串文字初始化，就像数字类型可以由任何有效的数字初始化一样。和基础数据类型语言，以下所有的初始化方法都是有效的：

```
string mystring = "This is a string";
string mystring ("This is a string");
string mystring {"This is a string"};
```

字符串可以进行基础数据类型有的所有操作，比如不带初始值进行声明，或者在执行过程中更改它的值：

```
// my first string
#include <iostream>
#include <string>
using namespace std;

int main ()
{
  string mystring;
  mystring = "This is the initial string content";
  cout << mystring << endl;
  mystring = "This is a different string content";
  cout << mystring << endl;
  return 0;
}
```

程序的输出：

```
This is the initial string content
This is a different string content
```

注意：插入*endl*操作符会在输出时换行。

*string*类是*复合类型*。正如你在上面看到的，*复合类型*和*基础类型*的用法是一样的：声明和初始化的语法相同。

想要获取更多有关C++字符串的内容，可以去看*string*参考手册。